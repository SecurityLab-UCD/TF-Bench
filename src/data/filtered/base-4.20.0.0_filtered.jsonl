{"id": "data/repos/base-4.20.0.0/src/System/Info.hs--compilerVersion", "code": "compilerVersion :: Version", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Info.hs--fullCompilerVersion", "code": "fullCompilerVersion :: Version", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Info.hs--version", "code": "version :: [Int]", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Info.hs--splitVersion", "code": "splitVersion :: String -> [String]\nsplitVersion s =\n  case dropWhile (== '.') s of\n    \"\" -> []\n    s' -> let (w, s'') = break (== '.') s'\n           in w : splitVersion s''", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Info.hs--: String\nos", "code": ": String\nos ", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Info.hs--", "code": " :: String\narc", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Info.hs--ilerName", "code": "ilerName :: String\ncom", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Info.hs--ilerVersionRaw", "code": "ilerVersionRaw :: Int\ncom", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Timeout.hs--imeout", "code": "imeout :: Int -> IO a -> IO (Maybe a)\n\nimeout n f\n    | n <  0    = fmap Just f\n    | n == 0    = return Nothing\n#if !defined(mingw32_HOST_OS) && !defined(javascript_HOST_ARCH)\n    | rtsSupportsBoundThreads = do\n        -- In the threaded RTS, we use the Timer Manager to delay the\n        -- (fairly expensive) 'forkIO' call until the timeout has expired.\n        --\n        -- An additional thread is required for the actual delivery of\n        -- the Timeout exception because killThread (or another throwTo)\n        -- is the only way to reliably interrupt a throwTo in flight.\n        pid <- myThreadId\n        ex  <- fmap Timeout newUnique\n        tm  <- getSystemTimerManager\n        -- 'lock' synchronizes the timeout handler and the main thread:\n        --  * the main thread can disable the handler by writing to 'lock';\n        --  * the handler communicates the spawned thread's id through 'lock'.\n        -- These two cases are mutually exclusive.\n        lock <- newEmptyMVar\n        let handleTimeout = do\n                v <- isEmptyMVar lock\n                when v $ void $ forkIOWithUnmask $ \\unmask -> unmask $ do\n                    v2 <- tryPutMVar lock =<< myThreadId\n                    when v2 $ throwTo pid ex\n            cleanupTimeout key = uninterruptibleMask_ $ do\n                v <- tryPutMVar lock undefined\n                if v then unregisterTimeout tm key\n                     else takeMVar lock >>= killThread\n        handleJust (\\e -> if e == ex then Just () else Nothing)\n                   (\\_ -> return Nothing)\n                   (bracket (registerTimeout tm n handleTimeout)\n                            cleanupTimeout\n                            (\\_ -> fmap Just f))\n#endif\n    | otherwise = do\n        pid <- myThreadId\n        ex  <- fmap Timeout newUnique\n        handleJust (\\e -> if e == ex then Just () else Nothing)\n                   (\\_ -> return Nothing)\n                   (bracket (forkIOWithUnmask $ \\unmask ->\n                                 unmask $ threadDelay n >> throwTo pid ex)\n                            (uninterruptibleMask_ . killThread)\n                            (\\_ -> fmap Just f))\n", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/IO/Unsafe.hs--unsafeFixIO", "code": "unsafeFixIO :: (a -> IO a) -> IO a\nunsafeFixIO k = do\n  ref <- newIORef (throw NonTermination)\n  ans <- unsafeDupableInterleaveIO (readIORef ref)\n  result <- k ans\n  writeIORef ref result\n  return result", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/CPUTime/Utils.hs--cClockToInteger", "code": "cClockToInteger :: CClock -> Integer\ncClockToInteger (CClock n) = fromIntegral n", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/CPUTime/Utils.hs--cTimeToInteger", "code": "cTimeToInteger :: CTime -> Integer\ncTimeToInteger (CTime n) = fromIntegral n", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/CPUTime/Utils.hs--csuSecondsToInteger", "code": "csuSecondsToInteger :: CSUSeconds -> Integer\ncsuSecondsToInteger (CSUSeconds n) = fromIntegral n", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/CPUTime/Javascript.hs--getCpuTimePrecision", "code": "getCpuTimePrecision :: IO Integer", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/CPUTime/Javascript.hs--getCPUTime", "code": "getCPUTime :: IO Integer", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/CPUTime/Javascript.hs--js_cpuTimePrecision", "code": "js_cpuTimePrecision :: IO Int", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/CPUTime/Javascript.hs--js_getCPUTime", "code": "js_getCPUTime :: IO Double", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/CPUTime/Unsupported.hs--getCPUTime", "code": "getCPUTime :: IO Integer", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/CPUTime/Unsupported.hs--getCpuTimePrecision", "code": "getCpuTimePrecision :: IO Integer", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Mem/Weak.hs--mkWeakPtr", "code": "mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)\nmkWeakPtr key finalizer = mkWeak key key finalizer", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Mem/Weak.hs--addFinalizer", "code": "addFinalizer :: key -> IO () -> IO ()\naddFinalizer key finalizer = do\n   _ <- mkWeakPtr key (Just finalizer) -- throw it away\n   return ()", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Mem/Weak.hs--mkWeakPair", "code": "mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k,v))\nmkWeakPair key val finalizer = mkWeak key (key,val) finalizer", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--usageInfo", "code": "usageInfo :: String                    -- header\n          -> [OptDescr a]              -- option descriptors\n          -> String\nusageInfo header optDescr = unlines (header:table)\n   where (ss,ls,ds)     = (unzip3 . concatMap fmtOpt) optDescr\n         table          = zipWith3 paste (sameLen ss) (sameLen ls) ds\n         paste x y z    = \"  \" ++ x ++ \"  \" ++ y ++ \"  \" ++ z\n         sameLen xs     = flushLeft ((maximum . map length) xs) xs\n         flushLeft n xs = [ take n (x ++ repeat ' ') | x <- xs ]", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--fmtOpt", "code": "fmtOpt :: OptDescr a -> [(String,String,String)]\nfmtOpt (Option sos los ad descr) =\n   case lines descr of\n     []     -> [(sosFmt,losFmt,\"\")]\n     (d:ds) ->  (sosFmt,losFmt,d) : [ (\"\",\"\",d') | d' <- ds ]\n   where sepBy _  []     = \"\"\n         sepBy _  [x]    = x\n         sepBy ch (x:xs) = x ++ ch:' ':sepBy ch xs\n         sosFmt = sepBy ',' (map (fmtShort ad) sos)\n         losFmt = sepBy ',' (map (fmtLong  ad) los)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--fmtShort", "code": "fmtShort :: ArgDescr a -> Char -> String\nfmtShort (NoArg  _   ) so = \"-\" ++ [so]\nfmtShort (OptArg _ ad) so = \"-\" ++ [so] ++ \"[\" ++ ad ++ \"]\"\nfmtShort (ReqArg _ ad) so = \"-\" ++ [so] ++ \" \" ++ ad", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--fmtLong", "code": "fmtLong :: ArgDescr a -> String -> String\nfmtLong (NoArg  _   ) lo = \"--\" ++ lo\nfmtLong (OptArg _ ad) lo = \"--\" ++ lo ++ \"[=\" ++ ad ++ \"]\"\nfmtLong (ReqArg _ ad) lo = \"--\" ++ lo ++ \"=\" ++ ad", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--getOpt", "code": "getOpt :: ArgOrder a                   -- non-option handling\n       -> [OptDescr a]                 -- option descriptors\n       -> [String]                     -- the command-line arguments\n       -> ([a],[String],[String])\ngetOpt ordering optDescr args = (os,xs,es ++ map errUnrec us)\n   where (os,xs,us,es) = getOpt' ordering optDescr args", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--getOpt'", "code": "getOpt' :: ArgOrder a                         -- non-option handling\n        -> [OptDescr a]                       -- option descriptors\n        -> [String]                           -- the command-line arguments\n        -> ([a],[String], [String] ,[String])\ngetOpt' _        _        []         =  ([],[],[],[])\ngetOpt' ordering optDescr (arg:args) = procNextOpt opt ordering\n   where procNextOpt (Opt o)      _                 = (o:os,xs,us,es)\n         procNextOpt (UnreqOpt u) _                 = (os,xs,u:us,es)\n         procNextOpt (NonOpt x)   RequireOrder      = ([],x:rest,[],[])\n         procNextOpt (NonOpt x)   Permute           = (os,x:xs,us,es)\n         procNextOpt (NonOpt x)   (ReturnInOrder f) = (f x :os, xs,us,es)\n         procNextOpt EndOfOpts    RequireOrder      = ([],rest,[],[])\n         procNextOpt EndOfOpts    Permute           = ([],rest,[],[])\n         procNextOpt EndOfOpts    (ReturnInOrder f) = (map f rest,[],[],[])\n         procNextOpt (OptErr e)   _                 = (os,xs,us,e:es)\n\n         (opt,rest) = getNext arg args optDescr\n         (os,xs,us,es) = getOpt' ordering optDescr rest", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--getNext", "code": "getNext :: String -> [String] -> [OptDescr a] -> (OptKind a,[String])\ngetNext ('-': x :xs) rest optDescr = shortOpt x xs rest optDescr\ngetNext ('-':'-':[]) rest _        = (EndOfOpts,rest)\ngetNext ('-':'-':xs) rest optDescr = longOpt xs rest optDescr\ngetNext a            rest _        = (NonOpt a,rest)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--longOpt", "code": "longOpt :: String -> [String] -> [OptDescr a] -> (OptKind a,[String])\nlongOpt ls rs optDescr = long ads arg rs\n   where (opt,arg) = break (=='=') ls\n         getWith p = [ o | o@(Option _ xs _ _) <- optDescr\n                         , find (p opt) xs /= Nothing ]\n         exact     = getWith (==)\n         options   = if null exact then getWith isPrefixOf else exact\n         ads       = [ ad | Option _ _ ad _ <- options ]\n         optStr    = (\"--\"++opt)\n\n         long (_:_:_)      _        rest     = (errAmbig options optStr,rest)\n         long [NoArg  a  ] []       rest     = (Opt a,rest)\n         long [NoArg  _  ] ('=':_)  rest     = (errNoArg optStr,rest)\n         long [ReqArg _ d] []       []       = (errReq d optStr,[])\n         long [ReqArg f _] []       (r:rest) = (Opt (f r),rest)\n         long [ReqArg f _] ('=':xs) rest     = (Opt (f xs),rest)\n         long [OptArg f _] []       rest     = (Opt (f Nothing),rest)\n         long [OptArg f _] ('=':xs) rest     = (Opt (f (Just xs)),rest)\n         long _            _        rest     = (UnreqOpt (\"--\"++ls),rest)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--shortOpt", "code": "shortOpt :: Char -> String -> [String] -> [OptDescr a] -> (OptKind a,[String])\nshortOpt y ys rs optDescr = short ads ys rs\n  where options = [ o  | o@(Option ss _ _ _) <- optDescr, s <- ss, y == s ]\n        ads     = [ ad | Option _ _ ad _ <- options ]\n        optStr  = '-':[y]\n\n        short (_:_:_)        _  rest     = (errAmbig options optStr,rest)\n        short (NoArg  a  :_) [] rest     = (Opt a,rest)\n        short (NoArg  a  :_) xs rest     = (Opt a,('-':xs):rest)\n        short (ReqArg _ d:_) [] []       = (errReq d optStr,[])\n        short (ReqArg f _:_) [] (r:rest) = (Opt (f r),rest)\n        short (ReqArg f _:_) xs rest     = (Opt (f xs),rest)\n        short (OptArg f _:_) [] rest     = (Opt (f Nothing),rest)\n        short (OptArg f _:_) xs rest     = (Opt (f (Just xs)),rest)\n        short []             [] rest     = (UnreqOpt optStr,rest)\n        short []             xs rest     = (UnreqOpt optStr,('-':xs):rest)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--errAmbig", "code": "errAmbig :: [OptDescr a] -> String -> OptKind a\nerrAmbig ods optStr = OptErr (usageInfo header ods)\n   where header = \"option `\" ++ optStr ++ \"' is ambiguous; could be one of:\"", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--errReq", "code": "errReq :: String -> String -> OptKind a\nerrReq d optStr = OptErr (\"option `\" ++ optStr ++ \"' requires an argument \" ++ d ++ \"\\n\")", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--errUnrec", "code": "errUnrec :: String -> String\nerrUnrec optStr = \"unrecognized option `\" ++ optStr ++ \"'\\n\"", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/System/Console/GetOpt.hs--errNoArg", "code": "errNoArg :: String -> OptKind a\nerrNoArg optStr = OptErr (\"option `\" ++ optStr ++ \"' doesn't allow an argument\\n\")", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--spr", "code": "spr :: String -> [UPrintf] -> t\nspr fmts args =\n        putStr $ map fromChar $ uprintf fmts $ reverse args\nspr fmts args = \\ a -> spr fmts\n                             ((parseFormat a, formatArg a) : args)\nspr fmts args = map fromChar (uprintf fmts (reverse args))", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--hspr", "code": "hspr :: Handle -> String -> [UPrintf] -> t\nhspr hdl fmts args =\n        hPutStr hdl (uprintf fmts (reverse args))\nhspr hdl fmts args = \\ a -> hspr hdl fmts\n                                  ((parseFormat a, formatArg a) : args)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--formatArg", "code": "formatArg :: a -> FieldFormatter", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--parseFormat", "code": "parseFormat :: a -> ModifierParser\nparseFormat _ \"\" = errorShortFormat\nparseFormat _ (c : cs) = FormatParse \"\" c cs\nparseFormat _ cf = parseIntFormat (undefined :: Int) cf", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--undefined", "code": "undefined :: Int", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--toChar", "code": "toChar :: c -> Char\ntoChar c = c", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--fromChar", "code": "fromChar :: Char -> c\nfromChar c = c", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--intModifierMap", "code": "intModifierMap :: [(String, Integer)]", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--minBound", "code": "minBound :: Int8", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--minBound", "code": "minBound :: Int16", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--minBound", "code": "minBound :: Int32", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--minBound", "code": "minBound :: Int64", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--minBound", "code": "minBound :: Int64", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--parseIntFormat", "code": "parseIntFormat :: a -> String -> FormatParse\nparseIntFormat _ s =\n  case foldr matchPrefix Nothing intModifierMap of\n    Just m -> m\n    Nothing ->\n      case s of\n        c : cs -> FormatParse \"\" c cs\n        \"\" -> errorShortFormat\n  where\n    matchPrefix (p, _) m@(Just (FormatParse p0 _ _))\n      | length p0 >= length p = m\n      | otherwise = case getFormat p of\n          Nothing -> m\n          Just fp -> Just fp\n    matchPrefix (p, _) Nothing =\n      getFormat p\n    getFormat p =\n      stripPrefix p s >>= fp\n      where\n        fp (c : cs) = Just $ FormatParse p c cs\n        fp \"\" = errorShortFormat", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--vFmt", "code": "vFmt :: Char -> FieldFormat -> FieldFormat\nvFmt _ ufmt = ufmt\nvFmt c ufmt@(FieldFormat {fmtChar = 'v'}) = ufmt {fmtChar = c}", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--formatChar", "code": "formatChar :: Char -> FieldFormatter\nformatChar x ufmt =\n  formatIntegral (Just 0) (toInteger $ ord x) $ vFmt 'c' ufmt", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--fixupMods", "code": "fixupMods :: FieldFormat -> Maybe Integer -> Maybe Integer\nfixupMods ufmt m =\n  let mods = fmtModifiers ufmt in\n  case mods of\n    \"\" -> m\n    _ -> case lookup mods intModifierMap of\n      Just m0 -> Just m0\n      Nothing -> perror \"unknown format modifier\"", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--formatInteger", "code": "formatInteger :: Integer -> FieldFormatter\nformatInteger x ufmt =\n  let m = fixupMods ufmt Nothing in\n  formatIntegral m x ufmt", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--formatIntegral", "code": "formatIntegral :: Maybe Integer -> Integer -> FieldFormatter\nformatIntegral m x ufmt0 =\n  let prec = fmtPrecision ufmt0 in\n  case fmtChar ufmt of\n    'd' -> (adjustSigned ufmt (fmti prec x) ++)\n    'i' -> (adjustSigned ufmt (fmti prec x) ++)\n    'x' -> (adjust ufmt (fmtu 16 (alt \"0x\" x) prec m x) ++)\n    'X' -> (adjust ufmt (upcase $ fmtu 16 (alt \"0X\" x) prec m x) ++)\n    'b' -> (adjust ufmt (fmtu 2 (alt \"0b\" x) prec m x) ++)\n    'o' -> (adjust ufmt (fmtu 8 (alt \"0\" x) prec m x) ++)\n    'u' -> (adjust ufmt (fmtu 10 Nothing prec m x) ++)\n    'c' | x >= fromIntegral (ord (minBound :: Char)) &&\n          x <= fromIntegral (ord (maxBound :: Char)) &&\n          fmtPrecision ufmt == Nothing &&\n          fmtModifiers ufmt == \"\" ->\n            formatString [chr $ fromIntegral x] (ufmt { fmtChar = 's' })\n    'c' -> perror \"illegal char conversion\"\n    c   -> errorBadFormat c\n  where\n    ufmt = vFmt 'd' $ case ufmt0 of\n      FieldFormat { fmtPrecision = Just _, fmtAdjust = Just ZeroPad } ->\n        ufmt0 { fmtAdjust = Nothing }\n      _ -> ufmt0\n    alt _ 0 = Nothing\n    alt p _ = case fmtAlternate ufmt of\n      True -> Just p\n      False -> Nothing\n    upcase (s1, s2) = (s1, map toUpper s2)", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--minBound", "code": "minBound :: Char", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--maxBound", "code": "maxBound :: Char", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--uprintf", "code": "uprintf :: String -> [UPrintf] -> String\nuprintf s us = uprintfs s us \"\"", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--uprintfs", "code": "uprintfs :: String -> [UPrintf] -> ShowS\nuprintfs \"\"       (_:_)    = errorShortFormat\nuprintfs \"\"       []       = id\nuprintfs ('%':'%':cs) us   = ('%' :) . uprintfs cs us\nuprintfs ('%':_)  []       = errorMissingArgument\nuprintfs ('%':cs) us@(_:_) = fmt cs us\nuprintfs (c:cs)   us       = (c :) . uprintfs cs us", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--fmt", "code": "fmt :: String -> [UPrintf] -> ShowS\nfmt cs0 us0 =\n  case getSpecs False False Nothing False cs0 us0 of\n    (_, _, []) -> errorMissingArgument\n    (ufmt, cs, (_, u) : us) -> u ufmt . uprintfs cs us", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--adjust", "code": "adjust :: FieldFormat -> (String, String) -> String\nadjust ufmt (pre, str) =\n  let naturalWidth = length pre + length str\n      zero = case fmtAdjust ufmt of\n        Just ZeroPad -> True\n        _ -> False\n      left = case fmtAdjust ufmt of\n        Just LeftAdjust -> True\n        _ -> False\n      fill = case fmtWidth ufmt of\n        Just width | naturalWidth < width ->\n          let fillchar = if zero then '0' else ' ' in\n          replicate (width - naturalWidth) fillchar\n        _ -> \"\"\n  in\n   if left\n   then pre ++ str ++ fill\n   else if zero\n        then pre ++ fill ++ str\n        else fill ++ pre ++ str", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--adjustSigned", "code": "adjustSigned :: FieldFormat -> (String, String) -> String\nadjustSigned ufmt ps =\n  adjust ufmt ps\nadjustSigned ufmt@(FieldFormat {fmtSign = Just SignPlus}) (\"\", str) =\n  adjust ufmt (\"+\", str)\nadjustSigned ufmt@(FieldFormat {fmtSign = Just SignSpace}) (\"\", str) =\n  adjust ufmt (\" \", str)", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--fmti", "code": "fmti :: Maybe Int -> Integer -> (String, String)\nfmti prec i\n  | i < 0 = (\"-\", integral_prec prec (show (-i)))\n  | otherwise = (\"\", integral_prec prec (show i))", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--fmtu", "code": "fmtu :: Integer -> Maybe String -> Maybe Int -> Maybe Integer -> Integer\n     -> (String, String)\nfmtu b (Just pre) prec m i =\n  let (\"\", s) = fmtu b Nothing prec m i in\n  case pre of\n    \"0\" -> case s of\n      '0' : _ -> (\"\", s)\n      _ -> (pre, s)\n    _ -> (pre, s)\nfmtu b Nothing prec0 m0 i0 =\n  case fmtu' prec0 m0 i0 of\n    Just s -> (\"\", s)\n    Nothing -> errorBadArgument\n  where\n    fmtu' :: Maybe Int -> Maybe Integer -> Integer -> Maybe String\n    fmtu' prec (Just m) i | i < 0 =\n      fmtu' prec Nothing (-2 * m + i)\n    fmtu' (Just prec) _ i | i >= 0 =\n      fmap (integral_prec (Just prec)) $ fmtu' Nothing Nothing i\n    fmtu' Nothing _ i | i >= 0 =\n      Just $ showIntAtBase b intToDigit i \"\"\n    fmtu' _ _ _ = Nothing", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--fmtu'", "code": "fmtu' :: Maybe Int -> Maybe Integer -> Integer -> Maybe String\nfmtu' (Just prec) _ i | i >= 0 =\n      fmap (integral_prec (Just prec)) $ fmtu' Nothing Nothing i\nfmtu' Nothing _ i | i >= 0 =\n      Just $ showIntAtBase b intToDigit i \"\"\nfmtu' _ _ _ = Nothing\nfmtu' prec (Just m) i | i < 0 =\n      fmtu' prec Nothing (-2 * m + i)", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--integral_prec", "code": "integral_prec :: Maybe Int -> String -> String\nintegral_prec (Just 0) \"0\" = \"\"\nintegral_prec (Just prec) integral =\n  replicate (prec - length integral) '0' ++ integral\nintegral_prec Nothing integral = integral", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--stoi", "code": "stoi :: String -> (Int, String)\nstoi cs =\n  let (as, cs') = span isDigit cs in\n  case as of\n    \"\" -> (0, cs')\n    _ -> (read as, cs')", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--adjustment", "code": "adjustment :: Maybe Int -> Maybe a -> Bool -> Bool\n           -> Maybe FormatAdjustment\nadjustment w p l z =\n  case w of\n    Just n | n < 0 -> adjl p True z\n    _ -> adjl p l z\n  where\n    adjl _ True _ = Just LeftAdjust\n    adjl _ False True = Just ZeroPad\n    adjl _ _ _ = Nothing", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--getSpecs", "code": "getSpecs :: Bool -> Bool -> Maybe FormatSign -> Bool -> String -> [UPrintf]\n         -> (FieldFormat, String, [UPrintf])\ngetSpecs _ _ _ _ \"\"       _  =\n  errorShortFormat\ngetSpecs _ z s a ('-' : cs0) us = getSpecs True z s a cs0 us\ngetSpecs l _ s a ('0' : cs0) us = getSpecs l True s a cs0 us\ngetSpecs l z _ a ('+' : cs0) us = getSpecs l z (Just SignPlus) a cs0 us\ngetSpecs l z s _ ('#' : cs0) us = getSpecs l z s True cs0 us\ngetSpecs l z s a (' ' : cs0) us =\n  getSpecs l z ss a cs0 us\n  where\n    ss = case s of\n      Just SignPlus -> Just SignPlus\n      _ -> Just SignSpace\ngetSpecs l z s a ('*' : cs0) us =\n  let (us', n) = getStar us\n      ((p, cs''), us'') = case cs0 of\n        '.':'*':r ->\n          let (us''', p') = getStar us' in ((Just p', r), us''')\n        '.':r ->\n          let (p', r') = stoi r in ((Just p', r'), us')\n        _ ->\n          ((Nothing, cs0), us')\n      FormatParse ms c cs =\n        case us'' of\n          (ufmt, _) : _ -> ufmt cs''\n          [] -> errorMissingArgument\n  in\n   (FieldFormat {\n       fmtWidth = Just (abs n),\n       fmtPrecision = p,\n       fmtAdjust = adjustment (Just n) p l z,\n       fmtSign = s,\n       fmtAlternate = a,\n       fmtModifiers = ms,\n       fmtChar = c}, cs, us'')\ngetSpecs l z s a ('.' : cs0) us =\n  let ((p, cs'), us') = case cs0 of\n        '*':cs'' -> let (us'', p') = getStar us in ((p', cs''), us'')\n        _ ->        (stoi cs0, us)\n      FormatParse ms c cs =\n        case us' of\n          (ufmt, _) : _ -> ufmt cs'\n          [] -> errorMissingArgument\n  in\n   (FieldFormat {\n       fmtWidth = Nothing,\n       fmtPrecision = Just p,\n       fmtAdjust = adjustment Nothing (Just p) l z,\n       fmtSign = s,\n       fmtAlternate = a,\n       fmtModifiers = ms,\n       fmtChar = c}, cs, us')\ngetSpecs l z s a cs0@(_ : _) us =\n  let FormatParse ms c cs =\n        case us of\n          (ufmt, _) : _ -> ufmt cs0\n          [] -> errorMissingArgument\n  in\n   (FieldFormat {\n       fmtWidth = Nothing,\n       fmtPrecision = Nothing,\n       fmtAdjust = adjustment Nothing Nothing l z,\n       fmtSign = s,\n       fmtAlternate = a,\n       fmtModifiers = ms,\n       fmtChar = c}, cs, us)\ngetSpecs l z s a cs0@(c0 : _) us | isDigit c0 =\n  let (n, cs') = stoi cs0\n      ((p, cs''), us') = case cs' of\n        '.' : '*' : r ->\n          let (us'', p') = getStar us in ((Just p', r), us'')\n        '.' : r ->\n          let (p', r') = stoi r in ((Just p', r'), us)\n        _ ->\n          ((Nothing, cs'), us)\n      FormatParse ms c cs =\n        case us' of\n          (ufmt, _) : _ -> ufmt cs''\n          [] -> errorMissingArgument\n  in\n   (FieldFormat {\n       fmtWidth = Just (abs n),\n       fmtPrecision = p,\n       fmtAdjust = adjustment (Just n) p l z,\n       fmtSign = s,\n       fmtAlternate = a,\n       fmtModifiers = ms,\n       fmtChar = c}, cs, us')", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--getStar", "code": "getStar :: [UPrintf] -> ([UPrintf], Int)\ngetStar us =\n  let ufmt = FieldFormat {\n        fmtWidth = Nothing,\n        fmtPrecision = Nothing,\n        fmtAdjust = Nothing,\n        fmtSign = Nothing,\n        fmtAlternate = False,\n        fmtModifiers = \"\",\n        fmtChar = 'd' } in\n  case us of\n    [] -> errorMissingArgument\n    (_, nu) : us' -> (us', read (nu ufmt \"\"))", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--perror", "code": "perror :: String -> a\nperror s = errorWithoutStackTrace $ \"printf: \" ++ s", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--errorBadFormat", "code": "errorBadFormat :: Char -> a\nerrorBadFormat c = perror $ \"bad formatting char \" ++ show c", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Text/Printf.hs--errorShortFormat, errorMissingArgument, errorBadArgument", "code": "errorShortFormat, errorMissingArgument, errorBadArgument :: a", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Complex.hs--realPart", "code": "realPart :: Complex a -> a\nrealPart (x :+ _) =  x", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Complex.hs--imagPart", "code": "imagPart :: Complex a -> a\nimagPart (_ :+ y) =  y", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Bifunctor.hs--(c -> d) -> p a c -> p b d\n    bimap f g = fir", "code": " (c -> d) -> p a c -> p b d\n    bimap f g = fir", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Bifunctor.hs--a c -> p b c\n    first f = bimap f", "code": " a c -> p b c\n    first f = bimap f", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Bifunctor.hs--a b -> p a c\n    second = bimap id", "code": "a b -> p a c\n    second = bimap id\n\n", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Foldable1.hs--toNonEmpty", "code": "toNonEmpty :: t a -> NonEmpty a\ntoNonEmpty (Functor.InL x) = toNonEmpty x\ntoNonEmpty (Functor.InR y) = toNonEmpty y\ntoNonEmpty (Identity x) = x :| []\ntoNonEmpty (MkSolo x) = x :| []\ntoNonEmpty (_, x) = x :| []\ntoNonEmpty (x :+ y) = x :| y : []", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Foldable1.hs--head", "code": "head :: t a -> a\nhead (Functor.InL x) = head x\nhead (Functor.InR y) = head y\nhead (Functor.Pair x _) = head x\nhead (MkSolo x) = x\nhead (_, x) = x", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Foldable1.hs--last", "code": "last :: t a -> a\nlast (Functor.InL x) = last x\nlast (Functor.InR y) = last y\nlast (Functor.Pair _ y) = last y\nlast (MkSolo x) = x\nlast (_, x) = x", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Foldable1.hs--foldrMap1", "code": "foldrMap1 :: (a -> b) -> (a -> b -> b) -> t a -> b\nfoldrMap1  g _ = coerce g\nfoldrMap1 f g = foldrMap1 (foldrMap1 f g) (\\xs x -> foldr g x xs) . getCompose\nfoldrMap1 f g xs =\n        appFromMaybe (foldMap1 (FromMaybe #. h) xs) Nothing\n      where\n        h a Nothing  = f a\n        h a (Just b) = g a b\nfoldrMap1 g f (Functor.InL x) = foldrMap1 g f x\nfoldrMap1 g f (Functor.InR y) = foldrMap1 g f y\nfoldrMap1 g f (Functor.Pair x y) = foldr f (foldrMap1 g f y) x\nfoldrMap1 g f (x :| xs) = go x xs where\n        go y [] = g y\n        go y (z : zs) = f y (go z zs)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Foldable1.hs--foldlMap1'", "code": "foldlMap1' :: (a -> b) -> (b -> a -> b) -> t a -> b\nfoldlMap1' f g xs =\n        foldrMap1 f' g' xs SNothing\n      where\n        -- f' :: a -> SMaybe b -> b\n        f' a SNothing  = f a\n        f' a (SJust b) = g b a\n\n        -- g' :: a -> (SMaybe b -> b) -> SMaybe b -> b\n        g' a x SNothing  = x $! SJust (f a)\n        g' a x (SJust b) = x $! SJust (g b a)\nfoldlMap1' g _ = coerce g\nfoldlMap1' g f (x :| xs) = let gx = g x in gx `seq` foldl' f gx xs", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Foldable1.hs--foldlMap1", "code": "foldlMap1 :: (a -> b) -> (b -> a -> b) -> t a -> b\nfoldlMap1  g _ = coerce g\nfoldlMap1  g f (x :| xs) = foldl f (g x) xs\nfoldlMap1 f g xs =\n        appFromMaybe (getDual (foldMap1 ((Dual . FromMaybe) #. h) xs)) Nothing\n      where\n        h a Nothing  = f a\n        h a (Just b) = g b a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Foldable1.hs--foldrMap1'", "code": "foldrMap1' :: (a -> b) -> (a -> b -> b) -> t a -> b\nfoldrMap1' f g xs =\n        foldlMap1 f' g' xs SNothing\n      where\n        f' a SNothing  = f a\n        f' a (SJust b) = g a b\n\n        g' bb a SNothing  = bb $! SJust (f a)\n        g' bb a (SJust b) = bb $! SJust (g a b)\nfoldrMap1' g _ = coerce g", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Foldable1.hs--singleton", "code": "singleton :: a -> NonEmptyDList a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Foldable1.hs--runNonEmptyDList", "code": "runNonEmptyDList :: NonEmptyDList a -> NonEmpty a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Bifoldable.hs--c) -> (b -> c -> c) -> c -> p a b -> c\n  bifoldr f g z t = a", "code": "c) -> (b -> c -> c) -> c -> p a b -> c\n  bifoldr f g z t = a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Bifoldable.hs---> (c -> b -> c) -> c -> p a b -> c\n  bifoldl f g z t = app", "code": " -> (c -> b -> c) -> c -> p a b -> c\n  bifoldl f g z t = app", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Bifoldable.hs--| The least element", "code": "| The least element ", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Bifoldable.hs--| The 'bisum' functi", "code": "| The 'bisum' functi", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Bitraversable.hs--tity b)\n              -> (c -> Identity d) -> t a c -> Identity (t b d))\n{-# INLINE bimapDefaul", "code": "tity b)\n              -> (c -> Identity d) -> t a c -> Identity (t b d))\n{-# INLINE bimapDefaul", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Bitraversable.hs--m ())\n              -> (b -> Const m ()) -> t a b -> Const m (t () ()))\n{-# INLINE bifoldMapDefa", "code": "m ())\n              -> (b -> Const m ()) -> t a b -> Const m (t () ()))\n{-# INLINE bifoldMapDefa", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Semigroup.hs--min", "code": "min :: a -> a -> a\nmin x@(Arg a _) y@(Arg b _)\n    | a <= b    = x\n    | otherwise = y", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Semigroup.hs--max", "code": "max :: a -> a -> a\nmax x@(Arg a _) y@(Arg b _)\n    | a >= b    = x\n    | otherwise = y", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Semigroup.hs--mappend", "code": "mappend :: m -> m -> m", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Semigroup.hs--mconcat", "code": "mconcat :: [m] -> m", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Char.hs--gitToInt", "code": "gitToInt :: Char -> Int\nd\ngitToInt c\n  | (fromIntegral dec::Word) <= 9 = dec\n  | (fromIntegral hexl::Word) <= 5 = hexl + 10\n  | (fromIntegral hexu::Word) <= 5 = hexu + 10\n  | otherwise = errorWithoutStackTrace (\"Char.digitToInt: not a digit \" ++ show c) -- sigh\n  where\n    dec = ord c - ord '0'\n    hexl = ord c - ord 'a'\n    hexu = ord c - ord 'A'\n\n", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Char.hs--omIntegral dec", "code": "omIntegral dec::Word) ", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Char.hs--omIntegral hexl", "code": "omIntegral hexl::Word) ", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Char.hs--omIntegral hexu", "code": "omIntegral hexu::Word) ", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Char.hs--ter", "code": "ter :: Char -> Bool\nisLe\nter c = case generalCategory c of\n        UppercaseLetter         -> True\n        LowercaseLetter         -> True\n        TitlecaseLetter         -> True\n        ModifierLetter          -> True\n        OtherLetter             -> True\n        _                       -> False\n\n-- ", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Char.hs--: Char -> Bool\nisMark", "code": ": Char -> Bool\nisMark ", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Char.hs--: Char -> Bool\nisNumber", "code": ": Char -> Bool\nisNumber ", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Char.hs--r", "code": "r :: Char -> Bool\nisSeparat\nr c = case generalCategory c of\n        Space                   -> True\n        LineSeparator           -> True\n        ParagraphSeparator      -> True\n        _                       -> False\n\n", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--tyFixed", "code": "tyFixed :: DataType", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--conMkFixed", "code": "conMkFixed :: Constr", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--a", "code": "a :: k\na -> (b,a)\na -> a\na -> a -> (b,a)\na -> a -> a\na -> a -> b\na -> b", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--resolution", "code": "resolution :: p a -> Integer\nresolution _ = 1\nresolution _ = 10\nresolution _ = 100\nresolution _ = 1000\nresolution _ = 1000000\nresolution _ = 1000000000\nresolution _ = 1000000000000\nresolution _ = natVal (Proxy :: Proxy n)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--Proxy", "code": "Proxy :: Proxy n\nProxy a -> f a", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--withType", "code": "withType :: (Proxy a -> f a) -> f a\nwithType foo = foo Proxy", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--chopZeros", "code": "chopZeros :: Integer -> String\nchopZeros 0 = \"\"\nchopZeros a = show a\nchopZeros a | mod a 10 == 0 = chopZeros (div a 10)", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--showIntegerZeros", "code": "showIntegerZeros :: Bool -> Int -> Integer -> String\nshowIntegerZeros True _ 0 = \"\"\nshowIntegerZeros chopTrailingZeros digits a = replicate (digits - length s) '0' ++ s' where\n    s = show a\n    s' = if chopTrailingZeros then chopZeros a else s", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--withDot", "code": "withDot :: String -> String\nwithDot \"\" = \"\"\nwithDot s = '.':s", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--logBase 10 (fromInteger res)", "code": "logBase 10 (fromInteger res) :: Double", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--Proxy", "code": "Proxy :: Proxy a\nProxy a -> f a", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Fixed.hs--logBase 10 (fromInteger r)", "code": "logBase 10 (fromInteger r) :: Double", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftEq", "code": "liftEq :: (a -> b -> Bool) -> f a -> f b -> Bool\nliftEq (===) (Generically1 as1) (Generically1 as2) = liftEq (===) (from1 as1) (from1 as2)\nliftEq _ (Just _) Nothing = False\nliftEq _ (_:_) [] = False\nliftEq _ Nothing (Just _) = False\nliftEq _ Nothing Nothing = True\nliftEq _ [] (_:_) = False\nliftEq _ [] [] = True\nliftEq _ _ _ = True\nliftEq eq (Down x) (Down y) = eq x y\nliftEq eq (Identity x) (Identity y) = eq x y\nliftEq eq (Just x) (Just y) = eq x y\nliftEq eq (MkSolo a) (MkSolo b) = a `eq` b\nliftEq eq (a :| as) (b :| bs) = eq a b && liftEq eq as bs\nliftEq eq (x :+ y) (u :+ v) = eq x u && eq y v\nliftEq eq (x:xs) (y:ys) = eq x y && liftEq eq xs ys", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftCompare", "code": "liftCompare :: (a -> b -> Ordering) -> f a -> f b -> Ordering\nliftCompare _ (Just _) Nothing = GT\nliftCompare _ (_:_) [] = GT\nliftCompare _ Nothing (Just _) = LT\nliftCompare _ Nothing Nothing = EQ\nliftCompare _ [] (_:_) = LT\nliftCompare _ [] [] = EQ\nliftCompare _ _ _ = EQ\nliftCompare cmp (Generically1 as1) (Generically1 as2) = liftCompare cmp (from1 as1) (from1 as2)\nliftCompare cmp (MkSolo a) (MkSolo b) = cmp a b\nliftCompare cmp (a :| as) (b :| bs) = cmp a b `mappend` liftCompare cmp as bs\nliftCompare comp (Down x) (Down y) = case comp x y of\n        LT -> GT\n        EQ -> EQ\n        GT -> LT\nliftCompare comp (Identity x) (Identity y) = comp x y\nliftCompare comp (Just x) (Just y) = comp x y\nliftCompare comp (x:xs) (y:ys) = comp x y `mappend` liftCompare comp xs ys", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftReadsPrec", "code": "liftReadsPrec :: (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)\nliftReadsPrec rdP rdL p s = readParen (p > 5) (\\s' -> do\n    (a, s'') <- rdP 6 s'\n    (\":|\", s''') <- lex s''\n    (as, s'''') <- rdL s'''\n    return (a :| as, s'''')) s\nliftReadsPrec rp _ = readsData $\n         readsUnaryWith rp \"Down\" Down\nliftReadsPrec rp rl = readPrec_to_S $\n        liftReadPrec (readS_to_Prec rp) (readS_to_Prec (const rl))", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftReadList", "code": "liftReadList :: (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]\nliftReadList rp rl = readPrec_to_S\n        (list $ liftReadPrec (readS_to_Prec rp) (readS_to_Prec (const rl))) 0", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftReadPrec", "code": "liftReadPrec :: ReadPrec a -> ReadPrec [a] -> ReadPrec (f a)\nliftReadPrec _ _ = parens (expectP (Ident \"Proxy\") *> pure Proxy)\nliftReadPrec _ rl = rl\nliftReadPrec rp _  = parens $ prec complexPrec $ do\n        x <- step rp\n        expectP (Symbol \":+\")\n        y <- step rp\n        return (x :+ y)\n      where\n        complexPrec = 6\nliftReadPrec rp _ =\n        parens (expectP (Ident \"Nothing\") *> pure Nothing)\n        <|>\n        readData (readUnaryWith rp \"Just\" Just)\nliftReadPrec rp _ = readData $\n         readUnaryWith rp \"Identity\" Identity\nliftReadPrec rp _ = readData (readUnaryWith rp \"MkSolo\" MkSolo)\nliftReadPrec rp rl = readS_to_Prec $\n        liftReadsPrec (readPrec_to_S rp) (readPrec_to_S rl 0)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftReadListPrec", "code": "liftReadListPrec :: ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]\nliftReadListPrec rp rl = readS_to_Prec $ \\_ ->\n        liftReadList (readPrec_to_S rp) (readPrec_to_S rl 0)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftShowsPrec", "code": "liftShowsPrec :: (Int -> a -> ShowS) -> ([a] -> ShowS) ->\n        Int -> f a -> ShowS\nliftShowsPrec _ _ _ Nothing = showString \"Nothing\"\nliftShowsPrec _ _ _ _ = showString \"Proxy\"\nliftShowsPrec _ sl _ = sl\nliftShowsPrec shwP shwL p (a :| as) = showParen (p > 5) $\n    shwP 6 a . showString \" :| \" . shwL as\nliftShowsPrec sp _ d (Down x) = showsUnaryWith sp \"Down\" d x\nliftShowsPrec sp _ d (Identity x) = showsUnaryWith sp \"Identity\" d x\nliftShowsPrec sp _ d (Just x) = showsUnaryWith sp \"Just\" d x\nliftShowsPrec sp _ d (MkSolo x) = showsUnaryWith sp \"MkSolo\" d x\nliftShowsPrec sp _ d (x :+ y) = showParen (d > complexPrec) $\n        sp (complexPrec+1) x . showString \" :+ \" . sp (complexPrec+1) y\n      where\n        complexPrec = 6", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftShowList", "code": "liftShowList :: (Int -> a -> ShowS) -> ([a] -> ShowS) ->\n        [f a] -> ShowS\nliftShowList sp sl = showListWith (liftShowsPrec sp sl 0)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftEq2", "code": "liftEq2 :: (a -> b -> Bool) -> (c -> d -> Bool) -> f a c -> f b d -> Bool\nliftEq2 _ _ (Left _) (Right _) = False\nliftEq2 _ _ (Right _) (Left _) = False\nliftEq2 _ e2 (Right x) (Right y) = e2 x y\nliftEq2 e1 _ (Left x) (Left y) = e1 x y\nliftEq2 e1 e2 (u1, u2, x1, y1) (v1, v2, x2, y2) =\n        u1 == v1 &&\n        u2 == v2 &&\n        e1 x1 x2 && e2 y1 y2\nliftEq2 e1 e2 (u1, x1, y1) (v1, x2, y2) =\n        u1 == v1 &&\n        e1 x1 x2 && e2 y1 y2\nliftEq2 e1 e2 (x1, y1) (x2, y2) = e1 x1 x2 && e2 y1 y2\nliftEq2 eq _ (Const x) (Const y) = eq x y", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftCompare2", "code": "liftCompare2 :: (a -> b -> Ordering) -> (c -> d -> Ordering) ->\n        f a c -> f b d -> Ordering\nliftCompare2 _ _ (Left _) (Right _) = LT\nliftCompare2 _ _ (Right _) (Left _) = GT\nliftCompare2 _ comp2 (Right x) (Right y) = comp2 x y\nliftCompare2 comp _ (Const x) (Const y) = comp x y\nliftCompare2 comp1 _ (Left x) (Left y) = comp1 x y\nliftCompare2 comp1 comp2 (u1, u2, x1, y1) (v1, v2, x2, y2) =\n        compare u1 v1 `mappend`\n        compare u2 v2 `mappend`\n        comp1 x1 x2 `mappend` comp2 y1 y2\nliftCompare2 comp1 comp2 (u1, x1, y1) (v1, x2, y2) =\n        compare u1 v1 `mappend`\n        comp1 x1 x2 `mappend` comp2 y1 y2\nliftCompare2 comp1 comp2 (x1, y1) (x2, y2) =\n        comp1 x1 x2 `mappend` comp2 y1 y2", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftReadsPrec2", "code": "liftReadsPrec2 :: (Int -> ReadS a) -> ReadS [a] ->\n        (Int -> ReadS b) -> ReadS [b] -> Int -> ReadS (f a b)\nliftReadsPrec2 rp1 rl1 rp2 rl2 = readPrec_to_S $\n        liftReadPrec2 (readS_to_Prec rp1) (readS_to_Prec (const rl1))\n                      (readS_to_Prec rp2) (readS_to_Prec (const rl2))", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftReadList2", "code": "liftReadList2 :: (Int -> ReadS a) -> ReadS [a] ->\n        (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]\nliftReadList2 rp1 rl1 rp2 rl2 = readPrec_to_S\n       (list $ liftReadPrec2 (readS_to_Prec rp1) (readS_to_Prec (const rl1))\n                             (readS_to_Prec rp2) (readS_to_Prec (const rl2))) 0", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftReadPrec2", "code": "liftReadPrec2 :: ReadPrec a -> ReadPrec [a] ->\n        ReadPrec b -> ReadPrec [b] -> ReadPrec (f a b)\nliftReadPrec2 rp _ _ _ = readData $\n         readUnaryWith rp \"Const\" Const\nliftReadPrec2 rp1 _ rp2 _ = parens $ paren $ do\n        x <- rp1\n        expectP (Punc \",\")\n        y <- rp2\n        return (x,y)\nliftReadPrec2 rp1 _ rp2 _ = parens $ paren $ do\n        x1 <- readPrec\n        expectP (Punc \",\")\n        x2 <- readPrec\n        expectP (Punc \",\")\n        y1 <- rp1\n        expectP (Punc \",\")\n        y2 <- rp2\n        return (x1,x2,y1,y2)\nliftReadPrec2 rp1 _ rp2 _ = parens $ paren $ do\n        x1 <- readPrec\n        expectP (Punc \",\")\n        y1 <- rp1\n        expectP (Punc \",\")\n        y2 <- rp2\n        return (x1,y1,y2)\nliftReadPrec2 rp1 _ rp2 _ = readData $\n         readUnaryWith rp1 \"Left\" Left <|>\n         readUnaryWith rp2 \"Right\" Right\nliftReadPrec2 rp1 rl1 rp2 rl2 = readS_to_Prec $\n        liftReadsPrec2 (readPrec_to_S rp1) (readPrec_to_S rl1 0)\n                       (readPrec_to_S rp2) (readPrec_to_S rl2 0)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftReadListPrec2", "code": "liftReadListPrec2 :: ReadPrec a -> ReadPrec [a] ->\n        ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]\nliftReadListPrec2 rp1 rl1 rp2 rl2 = readS_to_Prec $ \\_ ->\n        liftReadList2 (readPrec_to_S rp1) (readPrec_to_S rl1 0)\n                      (readPrec_to_S rp2) (readPrec_to_S rl2 0)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftShowsPrec2", "code": "liftShowsPrec2 :: (Int -> a -> ShowS) -> ([a] -> ShowS) ->\n        (Int -> b -> ShowS) -> ([b] -> ShowS) -> Int -> f a b -> ShowS\nliftShowsPrec2 _ _ sp2 _ d (Right x) = showsUnaryWith sp2 \"Right\" d x\nliftShowsPrec2 sp _ _ _ d (Const x) = showsUnaryWith sp \"Const\" d x\nliftShowsPrec2 sp1 _ _ _ d (Left x) = showsUnaryWith sp1 \"Left\" d x\nliftShowsPrec2 sp1 _ sp2 _ _ (x, y) =\n        showChar '(' . sp1 0 x . showChar ',' . sp2 0 y . showChar ')'\nliftShowsPrec2 sp1 _ sp2 _ _ (x1,x2,y1,y2)\n        = showChar '(' . showsPrec 0 x1\n        . showChar ',' . showsPrec 0 x2\n        . showChar ',' . sp1 0 y1\n        . showChar ',' . sp2 0 y2\n        . showChar ')'\nliftShowsPrec2 sp1 _ sp2 _ _ (x1,y1,y2)\n        = showChar '(' . showsPrec 0 x1\n        . showChar ',' . sp1 0 y1\n        . showChar ',' . sp2 0 y2\n        . showChar ')'", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftShowList2", "code": "liftShowList2 :: (Int -> a -> ShowS) -> ([a] -> ShowS) ->\n        (Int -> b -> ShowS) -> ([b] -> ShowS) -> [f a b] -> ShowS\nliftShowList2 sp1 sl1 sp2 sl2 =\n        showListWith (liftShowsPrec2 sp1 sl1 sp2 sl2 0)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftEq", "code": "liftEq :: (a1 -> a2 -> Bool) -> (Generically1 f a1 -> Generically1 f a2 -> Bool)\nliftEq (===) (Generically1 as1) (Generically1 as2) = liftEq (===) (from1 as1) (from1 as2)\nliftEq _ (Just _) Nothing = False\nliftEq _ (_:_) [] = False\nliftEq _ Nothing (Just _) = False\nliftEq _ Nothing Nothing = True\nliftEq _ [] (_:_) = False\nliftEq _ [] [] = True\nliftEq _ _ _ = True\nliftEq eq (Down x) (Down y) = eq x y\nliftEq eq (Identity x) (Identity y) = eq x y\nliftEq eq (Just x) (Just y) = eq x y\nliftEq eq (MkSolo a) (MkSolo b) = a `eq` b\nliftEq eq (a :| as) (b :| bs) = eq a b && liftEq eq as bs\nliftEq eq (x :+ y) (u :+ v) = eq x u && eq y v\nliftEq eq (x:xs) (y:ys) = eq x y && liftEq eq xs ys", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--liftCompare", "code": "liftCompare :: (a1 -> a2 -> Ordering) -> (Generically1 f a1 -> Generically1 f a2 -> Ordering)\nliftCompare _ (Just _) Nothing = GT\nliftCompare _ (_:_) [] = GT\nliftCompare _ Nothing (Just _) = LT\nliftCompare _ Nothing Nothing = EQ\nliftCompare _ [] (_:_) = LT\nliftCompare _ [] [] = EQ\nliftCompare _ _ _ = EQ\nliftCompare cmp (Generically1 as1) (Generically1 as2) = liftCompare cmp (from1 as1) (from1 as2)\nliftCompare cmp (MkSolo a) (MkSolo b) = cmp a b\nliftCompare cmp (a :| as) (b :| bs) = cmp a b `mappend` liftCompare cmp as bs\nliftCompare comp (Down x) (Down y) = case comp x y of\n        LT -> GT\n        EQ -> EQ\n        GT -> LT\nliftCompare comp (Identity x) (Identity y) = comp x y\nliftCompare comp (Just x) (Just y) = comp x y\nliftCompare comp (x:xs) (y:ys) = comp x y `mappend` liftCompare comp xs ys", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--readsData", "code": "readsData :: (String -> ReadS a) -> Int -> ReadS a\nreadsData reader d =\n    readParen (d > 10) $ \\ r -> [res | (kw,s) <- lex r, res <- reader kw s]", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--readData", "code": "readData :: ReadPrec a -> ReadPrec a\nreadData reader = parens $ prec 10 reader", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--readsUnaryWith", "code": "readsUnaryWith :: (Int -> ReadS a) -> String -> (a -> t) -> String -> ReadS t\nreadsUnaryWith rp name cons kw s =\n    [(cons x,t) | kw == name, (x,t) <- rp 11 s]", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--readUnaryWith", "code": "readUnaryWith :: ReadPrec a -> String -> (a -> t) -> ReadPrec t\nreadUnaryWith rp name cons = do\n    expectP $ Ident name\n    x <- step rp\n    return $ cons x", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--readsBinaryWith", "code": "readsBinaryWith :: (Int -> ReadS a) -> (Int -> ReadS b) ->\n    String -> (a -> b -> t) -> String -> ReadS t\nreadsBinaryWith rp1 rp2 name cons kw s =\n    [(cons x y,u) | kw == name, (x,t) <- rp1 11 s, (y,u) <- rp2 11 t]", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--readBinaryWith", "code": "readBinaryWith :: ReadPrec a -> ReadPrec b ->\n    String -> (a -> b -> t) -> ReadPrec t\nreadBinaryWith rp1 rp2 name cons = do\n    expectP $ Ident name\n    x <- step rp1\n    y <- step rp2\n    return $ cons x y", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--showsUnaryWith", "code": "showsUnaryWith :: (Int -> a -> ShowS) -> String -> Int -> a -> ShowS\nshowsUnaryWith sp name d x = showParen (d > 10) $\n    showString name . showChar ' ' . sp 11 x", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Classes.hs--showsBinaryWith", "code": "showsBinaryWith :: (Int -> a -> ShowS) -> (Int -> b -> ShowS) ->\n    String -> Int -> a -> b -> ShowS\nshowsBinaryWith sp1 sp2 name d x y = showParen (d > 10) $\n    showString name . showChar ' ' . sp1 11 x . showChar ' ' . sp2 11 y", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Compose.hs--liftReadPrecCompose", "code": "liftReadPrecCompose :: ReadPrec (f (g a)) -> ReadPrec (Compose f g a)\nliftReadPrecCompose rp = readData $ readUnaryWith rp \"Compose\" Compose", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Compose.hs--liftShowsPrecCompose", "code": "liftShowsPrecCompose :: (Int -> f (g a) -> ShowS) -> Int -> Compose f g a -> ShowS\nliftShowsPrecCompose sp d (Compose x) = showsUnaryWith sp \"Compose\" d x", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Compose.hs--(<|>)", "code": "(<|>) :: f (g a) -> f (g a) -> f (g a)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Compose.hs--fmap sequenceA . some", "code": "fmap sequenceA . some :: f (g a) -> f (g [a])", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Compose.hs--fmap sequenceA . many", "code": "fmap sequenceA . many :: f (g a) -> f (g [a])", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--contramap", "code": "contramap :: (a' -> a) -> (f a -> f a')", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--(>$)", "code": "(>$) :: b -> f b -> f a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> (V1 a -> V1 a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> (U1 a -> U1 a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> (K1 i c a -> K1 i c a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> ((f :*: g) a -> (f :*: g) a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> ((f :.: g) a -> (f :.: g) a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> ((f :+: g) a -> (f :+: g) a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> (Sum f g a -> Sum f g a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> (Product f g a -> Product f g a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (b' -> b) -> (Const a b -> Const a b')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> (Compose f g a -> Compose f g a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> (Proxy a -> Proxy a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> (Comparison a -> Comparison a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (a' -> a) -> (Equivalence a -> Equivalence a')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--arisonEquivalence", "code": "arisonEquivalence :: Comparison a -> Equivalence a\ncom\narisonEquivalence (Comparison p) = Equivalence $ \\a b -> p a b == EQ\n\n--", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--: Op a a\n  i", "code": ": Op a a\n  i", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--", "code": ":: Op b c -> Op a b -> Op a c\n  O\n (Op f) = Op $ acos . f\n  s\n (Op f) = Op $ asin . f\n  a\n (Op f) = Op $ atan . f\n  a\n (Op f) = Op $ cosh . f\n  a\n (Op f) = Op $ sinh . f\n  t\n (Op f) = Op $ sqrt . f\n  l\n (Op f) = Op $ tanh . f\n  c\n * Op g = Op $ \\a -> f a * g a\n  O\n ** Op g = Op $ \\a -> f a ** g a\n  l\n + Op g = Op $ \\a -> f a + g a\n  O\n - Op g = Op $ \\a -> f a - g a\n  a\n -> U1 a')\n  \n -> V1 a')\n  \n . Op g = Op (g . f)\n\nin\n / Op g = Op $ \\a -> f a / g a\n  r\n All\n\n  \n All\n\n--\n Bool }\n \n Bool }\n \n Ordering }\n \n a -> All\n\n--\n a -> Bool }\n \n a -> Ordering }\n \n a }\n \n b -> Op a b')\n  \n b -> Op a c\n  O\n b) ->\n b) ->\n c -> Op a b -> Op a c\n  O\n c a -> K1 i c a')\n  \n f a\n($<", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Functor/Contravariant.hs--ramap", "code": "ramap :: (b' -> b) -> (Op a b -> Op a b')\n  c\nramap _ (Const a) = Const a\n\nin\nramap _ (K1 c) = K1 c\n\nin\nramap _ _ = Proxy\n\nne\nramap _ _ = U1\n\nin\nramap _ x = case x of\n\nin\nramap f (Comp1 fg) = Comp1 (fmap (contramap f) fg)\n\nin\nramap f (Comparison g) = Comparison (on g f)\n\n--\nramap f (Compose fga) = Compose (fmap (contramap f) fga)\n\nin\nramap f (Equivalence g) = Equivalence (on g f)\n\n--\nramap f (InL xs) = InL (contramap f xs)\n  c\nramap f (InR ys) = InR (contramap f ys)\n\nin\nramap f (L1 xs) = L1 (contramap f xs)\n  c\nramap f (Pair a b) = Pair (contramap f a) (contramap f b)\n\nin\nramap f (R1 ys) = R1 (contramap f ys)\n\nin\nramap f (xs :*: ys) = contramap f xs :*: contramap f ys\n\nin\nramap f g = Op (getOp g . f)\n\nin", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/STRef/Lazy.hs--newSTRef", "code": "newSTRef    :: a -> ST s (ST.STRef s a)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/STRef/Lazy.hs--readSTRef", "code": "readSTRef   :: ST.STRef s a -> ST s a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/STRef/Lazy.hs--writeSTRef", "code": "writeSTRef  :: ST.STRef s a -> a -> ST s ()\nwriteSTRef  r a = strictToLazyST (ST.writeSTRef r a)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/STRef/Lazy.hs--modifySTRef", "code": "modifySTRef :: ST.STRef s a -> (a -> a) -> ST s ()\nmodifySTRef r f = strictToLazyST (ST.modifySTRef r f)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--newByteArray", "code": "newByteArray :: Int -> ST s (MutableByteArray s)\nnewByteArray (I# n#) =\n  ST (\\s# -> case newByteArray# n# s# of\n    (# s'#, arr# #) -> (# s'#, MutableByteArray arr# #))", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--unsafeFreezeByteArray", "code": "unsafeFreezeByteArray :: MutableByteArray s -> ST s ByteArray\nunsafeFreezeByteArray (MutableByteArray arr#) =\n  ST (\\s# -> case unsafeFreezeByteArray# arr# s# of\n    (# s'#, arr'# #) -> (# s'#, ByteArray arr'# #))", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--sizeofByteArray", "code": "sizeofByteArray :: ByteArray -> Int\nsizeofByteArray (ByteArray arr#) = I# (sizeofByteArray# arr#)", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--indexByteArray", "code": "indexByteArray :: ByteArray -> Int -> Word8\nindexByteArray (ByteArray arr#) (I# i#) = W8# (indexWord8Array# arr# i#)", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--writeByteArray", "code": "writeByteArray :: MutableByteArray s -> Int -> Word8 -> ST s ()\nwriteByteArray (MutableByteArray arr#) (I# i#) (W8# x#) =\n  ST (\\s# -> case writeWord8Array# arr# i# x# s# of\n    s'# -> (# s'#, () #))", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--byteArrayToList", "code": "byteArrayToList :: ByteArray -> [Word8]\nbyteArrayToList arr = go 0\n  where\n    go i\n      | i < maxI  = indexByteArray arr i : go (i+1)\n      | otherwise = []\n    maxI = sizeofByteArray arr", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--byteArrayFromListN", "code": "byteArrayFromListN :: Int -> [Word8] -> ByteArray\nbyteArrayFromListN n ys\n  | n >= 0 = runST $ do\n    marr <- newByteArray n\n    let go !ix [] = if ix == n\n          then return ()\n          else errorWithoutStackTrace $ \"Data.Array.Byte.byteArrayFromListN: list length less than specified size\"\n        go !ix (x : xs) = if ix < n\n          then do\n            writeByteArray marr ix x\n            go (ix + 1) xs\n          else errorWithoutStackTrace $ \"Data.Array.Byte.byteArrayFromListN: list length greater than specified size\"\n    go 0 ys\n    unsafeFreezeByteArray marr\n  | otherwise = errorWithoutStackTrace \"Data.Array.Byte.ByteArrayFromListN: specified size is negative\"", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--unsafeCopyByteArray", "code": "unsafeCopyByteArray\n  :: MutableByteArray s -- ^ destination array\n  -> Int                -- ^ offset into destination array\n  -> ByteArray          -- ^ source array\n  -> Int                -- ^ offset into source array\n  -> Int                -- ^ number of bytes to copy\n  -> ST s ()\nunsafeCopyByteArray (MutableByteArray dst#) (I# doff#) (ByteArray src#) (I# soff#) (I# sz#) =\n  ST (\\s# -> case copyByteArray# src# soff# dst# doff# sz# s# of\n    s'# -> (# s'#, () #))", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--unsafeCopyMutableByteArray", "code": "unsafeCopyMutableByteArray\n  :: MutableByteArray s -- ^ destination array\n  -> Int                -- ^ offset into destination array\n  -> MutableByteArray s -- ^ source array\n  -> Int                -- ^ offset into source array\n  -> Int                -- ^ number of bytes to copy\n  -> ST s ()\nunsafeCopyMutableByteArray (MutableByteArray dst#) (I# doff#) (MutableByteArray src#) (I# soff#) (I# sz#) =\n  ST (\\s# -> case copyMutableByteArrayNonOverlapping# src# soff# dst# doff# sz# s# of\n    s'# -> (# s'#, () #))", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--showW8", "code": "showW8 :: Word8 -> String -> String\nshowW8 !w s =\n          '0'\n        : 'x'\n        : intToDigit (fromIntegral (unsafeShiftR w 4))\n        : intToDigit (fromIntegral (w .&. 0x0F))\n        : s", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--indexByteArray ba i", "code": "indexByteArray ba i :: Word8", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--compareByteArraysFromBeginning", "code": "compareByteArraysFromBeginning :: ByteArray -> ByteArray -> Int -> Ordering\ncompareByteArraysFromBeginning (ByteArray ba1#) (ByteArray ba2#) (I# n#)\n  = compare (I# (compareByteArrays# ba1# 0# ba2# 0# n#)) 0", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--sameByteArray", "code": "sameByteArray :: ByteArray# -> ByteArray# -> Bool\nsameByteArray ba1 ba2 =\n    case sameByteArray# ba1 ba2 of r -> isTrue# r", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--appendByteArray", "code": "appendByteArray :: ByteArray -> ByteArray -> ByteArray\nappendByteArray ba1 ba2 = runST $ do\n  let n1 = sizeofByteArray ba1\n      n2 = sizeofByteArray ba2\n      totSz = fromMaybe (sizeOverflowError \"appendByteArray\")\n                        (checkedIntAdd n1 n2)\n  marr <- newByteArray totSz\n  unsafeCopyByteArray marr 0  ba1 0 n1\n  unsafeCopyByteArray marr n1 ba2 0 n2\n  unsafeFreezeByteArray marr", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--concatByteArray", "code": "concatByteArray :: [ByteArray] -> ByteArray\nconcatByteArray arrs = runST $ do\n  let addLen acc arr = fromMaybe (sizeOverflowError \"concatByteArray\")\n                                 (checkedIntAdd acc (sizeofByteArray arr))\n      totLen = F.foldl' addLen 0 arrs\n  marr <- newByteArray totLen\n  pasteByteArrays marr 0 arrs\n  unsafeFreezeByteArray marr", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--pasteByteArrays", "code": "pasteByteArrays :: MutableByteArray s -> Int -> [ByteArray] -> ST s ()\npasteByteArrays !_ !_ [] = return ()\npasteByteArrays !marr !ix (x : xs) = do\n  unsafeCopyByteArray marr ix x 0 (sizeofByteArray x)\n  pasteByteArrays marr (ix + sizeofByteArray x) xs", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--emptyByteArray", "code": "emptyByteArray :: ByteArray", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--stimesNegativeErr", "code": "stimesNegativeErr :: ByteArray", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--stimesOverflowErr", "code": "stimesOverflowErr :: a", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--stimesPositiveInt", "code": "stimesPositiveInt :: Int -> ByteArray -> ByteArray\nstimesPositiveInt n arr = runST $ do\n  let inpSz = sizeofByteArray arr\n      tarSz = fromMaybe stimesOverflowErr (checkedIntMultiply n inpSz)\n  marr <- newByteArray tarSz\n  unsafeCopyByteArray marr 0 arr 0 inpSz\n  let\n    halfTarSz = (tarSz - 1) `div` 2\n    go copied\n      | copied <= halfTarSz = do\n          unsafeCopyMutableByteArray marr copied marr 0 copied\n          go (copied + copied)\n      | otherwise = unsafeCopyMutableByteArray marr copied marr 0 (tarSz - copied)\n  go inpSz\n  unsafeFreezeByteArray marr", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--sizeOverflowError", "code": "sizeOverflowError :: String -> a\nsizeOverflowError fun\n  = errorWithoutStackTrace $ \"Data.Array.Byte.\" ++ fun ++ \": size overflow\"", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--checkedIntAdd", "code": "checkedIntAdd :: Int -> Int -> Maybe Int\ncheckedIntAdd (I# x#) (I# y#) = case addIntC# x# y# of\n  (# res, 0# #) -> Just (I# res)\n  _ -> Nothing", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/Array/Byte.hs--checkedIntMultiply", "code": "checkedIntMultiply :: Int -> Int -> Maybe Int\ncheckedIntMultiply (I# x#) (I# y#) = case timesInt2# x# y# of\n  (# 0#, _hi, lo #) -> Just (I# lo)\n  _ -> Nothing", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--length", "code": "length :: NonEmpty a -> Int\nlength (_ :| xs) = 1 + Prelude.length xs", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--xor", "code": "xor :: NonEmpty Bool -> Bool\nxor (x :| xs)   = foldr xor' x xs\n  where xor' True y  = not y\n        xor' False y = y", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--unfold", "code": "unfold :: (a -> (b, Maybe a)) -> a -> NonEmpty b\nunfold f a = case f a of\n  (b, Nothing) -> b :| []\n  (b, Just c)  -> b <| unfold f c", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--nonEmpty", "code": "nonEmpty :: [a] -> Maybe (NonEmpty a)\nnonEmpty (a:as) = Just (a :| as)\nnonEmpty []     = Nothing", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--uncons", "code": "uncons :: NonEmpty a -> (a, Maybe (NonEmpty a))\nuncons ~(a :| as) = (a, nonEmpty as)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--unfoldr", "code": "unfoldr :: (a -> (b, Maybe a)) -> a -> NonEmpty b\nunfoldr f a = case f a of\n  (b, mc) -> b :| maybe [] go mc\n where\n    go c = case f c of\n      (d, me) -> d : maybe [] go me", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--head", "code": "head :: NonEmpty a -> a\nhead (a :| _) = a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--tail", "code": "tail :: NonEmpty a -> [a]\ntail (_ :| as) = as", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--last", "code": "last :: NonEmpty a -> a\nlast ~(a :| as) = List.last (a : as)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--init", "code": "init :: NonEmpty a -> [a]\ninit ~(a :| as) = List.init (a : as)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--singleton", "code": "singleton :: a -> NonEmpty a\nsingleton a = a :| []", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--(<|)", "code": "(<|) :: a -> NonEmpty a -> NonEmpty a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--cons", "code": "cons :: a -> NonEmpty a -> NonEmpty a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--toList", "code": "toList :: NonEmpty a -> [a]\ntoList ~(a :| as) = a : as", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--map", "code": "map :: (a -> b) -> NonEmpty a -> NonEmpty b\nmap f ~(a :| as) = f a :| fmap f as", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--inits1", "code": "inits1 :: NonEmpty a -> NonEmpty (NonEmpty a)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--tails1", "code": "tails1 :: NonEmpty a -> NonEmpty (NonEmpty a)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--scanl1", "code": "scanl1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a\nscanl1 f ~(a :| as) = fromList (List.scanl f a as)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--scanr1", "code": "scanr1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a\nscanr1 f ~(a :| as) = fromList (List.scanr1 f (a:as))", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--intersperse", "code": "intersperse :: a -> NonEmpty a -> NonEmpty a\nintersperse a ~(b :| bs) = b :| case bs of\n    [] -> []\n    _ -> a : List.intersperse a bs", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--iterate", "code": "iterate :: (a -> a) -> a -> NonEmpty a\niterate f a = a :| List.iterate f (f a)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--cycle", "code": "cycle :: NonEmpty a -> NonEmpty a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--reverse", "code": "reverse :: NonEmpty a -> NonEmpty a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--repeat", "code": "repeat :: a -> NonEmpty a\nrepeat a = a :| List.repeat a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--take", "code": "take :: Int -> NonEmpty a -> [a]\ntake n = List.take n . toList", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--drop", "code": "drop :: Int -> NonEmpty a -> [a]\ndrop n = List.drop n . toList", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--splitAt", "code": "splitAt :: Int -> NonEmpty a -> ([a],[a])\nsplitAt n = List.splitAt n . toList", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--takeWhile", "code": "takeWhile :: (a -> Bool) -> NonEmpty a -> [a]\ntakeWhile p = List.takeWhile p . toList", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--dropWhile", "code": "dropWhile :: (a -> Bool) -> NonEmpty a -> [a]\ndropWhile p = List.dropWhile p . toList", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--span", "code": "span :: (a -> Bool) -> NonEmpty a -> ([a], [a])\nspan p = List.span p . toList", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--break", "code": "break :: (a -> Bool) -> NonEmpty a -> ([a], [a])\nbreak p = span (not . p)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--filter", "code": "filter :: (a -> Bool) -> NonEmpty a -> [a]\nfilter p = List.filter p . toList", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--partition", "code": "partition :: (a -> Bool) -> NonEmpty a -> ([a], [a])\npartition p = List.partition p . toList", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--groupBy1", "code": "groupBy1 :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)\ngroupBy1 eq (x :| xs) = (x :| ys) :| groupBy eq zs\n  where (ys, zs) = List.span (eq x) xs", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--permutations", "code": "permutations            :: [a] -> NonEmpty [a]\npermutations xs0        =  xs0 :| perms xs0 []\n  where\n    perms []     _  = []\n    perms (t:ts) is = foldr interleave (perms ts (t:is)) (permutations is)\n      where interleave    xs     r = let (_,zs) = interleave' id xs r in zs\n            interleave' _ []     r = (ts, r)\n            interleave' f (y:ys) r = let (us,zs) = interleave' (f . (y:)) ys r\n                                     in  (y:us, f (t:y:us) : zs)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--permutations1", "code": "permutations1 :: NonEmpty a -> NonEmpty (NonEmpty a)\npermutations1 xs = fromList <$> permutations (toList xs)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--zip", "code": "zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a,b)\nzip ~(x :| xs) ~(y :| ys) = (x, y) :| List.zip xs ys", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--zipWith", "code": "zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c\nzipWith f ~(x :| xs) ~(y :| ys) = f x y :| List.zipWith f xs ys", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--nubBy", "code": "nubBy :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty a\nnubBy eq (a :| as) = a :| List.nubBy eq (List.filter (\\b -> not (eq a b)) as)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--transpose", "code": "transpose :: NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--sortBy", "code": "sortBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a\nsortBy f = lift (List.sortBy f)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--append", "code": "append :: NonEmpty a -> NonEmpty a -> NonEmpty a", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--appendList", "code": "appendList :: NonEmpty a -> [a] -> NonEmpty a\nappendList (x :| xs) ys = x :| xs <> ys", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Data/List/NonEmpty.hs--prependList", "code": "prependList :: [a] -> NonEmpty a -> NonEmpty a\nprependList ls ne = case ls of\n  [] -> ne\n  (x : xs) -> x :| xs <> toList ne", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--forkFinally", "code": "forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId\nforkFinally action and_then =\n  mask $ \\restore ->\n    forkIO $ try (restore action) >>= and_then", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--threadWaitRead", "code": "threadWaitRead :: Fd -> IO ()\nthreadWaitRead fd\n#if defined(mingw32_HOST_OS)\n  -- we have no IO manager implementing threadWaitRead on Windows.\n  -- fdReady does the right thing, but we have to call it in a\n  -- separate thread, otherwise threadWaitRead won't be interruptible,\n  -- and this only works with -threaded.\n  | threaded  = withThread (waitFd fd False)\n  | otherwise = case fd of\n                  0 -> do _ <- hWaitForInput stdin (-1)\n                          return ()\n                        -- hWaitForInput does work properly, but we can only\n                        -- do this for stdin since we know its FD.\n                  _ -> errorWithoutStackTrace \"threadWaitRead requires -threaded on Windows, or use GHC.System.IO.hWaitForInput\"", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--threadWaitWrite", "code": "threadWaitWrite :: Fd -> IO ()\nthreadWaitWrite fd\n#if defined(mingw32_HOST_OS)\n  | threaded  = withThread (waitFd fd True)\n  | otherwise = errorWithoutStackTrace \"threadWaitWrite requires -threaded on Windows\"", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--threadWaitReadSTM", "code": "threadWaitReadSTM :: Fd -> IO (STM (), IO ())\nthreadWaitReadSTM fd\n#if defined(mingw32_HOST_OS)\n  | threaded = do v <- newTVarIO Nothing\n                  mask_ $ void $ forkIO $ do result <- try (waitFd fd False)\n                                             atomically (writeTVar v $ Just result)\n                  let waitAction = do result <- readTVar v\n                                      case result of\n                                        Nothing         -> retry\n                                        Just (Right ()) -> return ()\n                                        Just (Left e)   -> throwSTM (e :: IOException)\n                  let killAction = return ()\n                  return (waitAction, killAction)\n  | otherwise = errorWithoutStackTrace \"threadWaitReadSTM requires -threaded on Windows\"", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--e", "code": "e :: IOException", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--threadWaitWriteSTM", "code": "threadWaitWriteSTM :: Fd -> IO (STM (), IO ())\nthreadWaitWriteSTM fd\n#if defined(mingw32_HOST_OS)\n  | threaded = do v <- newTVarIO Nothing\n                  mask_ $ void $ forkIO $ do result <- try (waitFd fd True)\n                                             atomically (writeTVar v $ Just result)\n                  let waitAction = do result <- readTVar v\n                                      case result of\n                                        Nothing         -> retry\n                                        Just (Right ()) -> return ()\n                                        Just (Left e)   -> throwSTM (e :: IOException)\n                  let killAction = return ()\n                  return (waitAction, killAction)\n  | otherwise = errorWithoutStackTrace \"threadWaitWriteSTM requires -threaded on Windows\"", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--e", "code": "e :: IOException", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--threaded", "code": "threaded :: Bool", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--withThread", "code": "withThread :: IO a -> IO a\nwithThread io = do\n  m <- newEmptyMVar\n  _ <- mask_ $ forkIO $ try io >>= putMVar m\n  x <- takeMVar m\n  case x of\n    Right a -> return a\n    Left e  -> throwIO (e :: IOException)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--e", "code": "e :: IOException", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--waitFd", "code": "waitFd :: Fd -> Bool -> IO ()\nwaitFd fd write = do\n   throwErrnoIfMinus1_ \"fdReady\" $\n        fdReady (fromIntegral fd) (if write then 1 else 0) (-1) 0", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent.hs--fdReady", "code": "fdReady :: CInt -> CBool -> Int64 -> CBool -> IO CInt", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Applicative.hs--m", "code": "m :: Type -> Type", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Applicative.hs--a", "code": "a :: Type -> Type -> Type", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/QSemN.hs--newQSemN", "code": "newQSemN :: Int -> IO QSemN\nnewQSemN initial\n  | initial < 0 = fail \"newQSemN: Initial quantity must be non-negative\"\n  | otherwise   = do\n      sem <- newIORef (initial, [], [])\n      return (QSemN sem)", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/QSemN.hs--waitQSemN", "code": "waitQSemN :: QSemN -> Int -> IO ()\nwaitQSemN qs@(QSemN m) sz = mask_ $ do\n    -- unsafePerformIO and not unsafeDupablePerformIO. We must\n    -- be sure to wait on the same MVar that gets enqueued.\n  mmvar <- atomicModifyIORef m $ \\ (i,b1,b2) -> unsafePerformIO $ do\n    let z = i-sz\n    if z < 0\n      then do\n        b <- newEmptyMVar\n        return ((i, b1, (sz,b):b2), JustMV b)\n      else return ((z, b1, b2), NothingMV)\n\n  -- Note: this case match actually allocates the MVar if necessary.\n  case mmvar of\n    NothingMV -> return ()\n    JustMV b -> wait b\n  where\n    wait :: MVar () -> IO ()\n    wait b =\n      takeMVar b `onException` do\n        already_filled <- not <$> tryPutMVar b ()\n        when already_filled $ signalQSemN qs sz", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/QSemN.hs--wait", "code": "wait :: MVar () -> IO ()\nwait b =\n      takeMVar b `onException` do\n        already_filled <- not <$> tryPutMVar b ()\n        when already_filled $ signalQSemN qs sz", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/QSemN.hs--signalQSemN", "code": "signalQSemN :: QSemN -> Int -> IO ()\nsignalQSemN (QSemN m) sz0 = do\n    -- unsafePerformIO and not unsafeDupablePerformIO. We must not\n    -- wake up more threads than we're supposed to.\n  unit <- atomicModifyIORef m $ \\(i,a1,a2) ->\n            unsafePerformIO (loop (sz0 + i) a1 a2)\n\n  -- Forcing this will actually wake the necessary threads.\n  evaluate unit\n where\n   loop 0  bs b2 = return ((0,  bs, b2), ())\n   loop sz [] [] = return ((sz, [], []), ())\n   loop sz [] b2 = loop sz (reverse b2) []\n   loop sz ((j,b):bs) b2\n     | j > sz = do\n       r <- isEmptyMVar b\n       if r then return ((sz, (j,b):bs, b2), ())\n            else loop sz bs b2\n     | otherwise = do\n       r <- tryPutMVar b ()\n       if r then loop (sz-j) bs b2\n            else loop sz bs b2", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/QSem.hs--newQSem", "code": "newQSem :: Int -> IO QSem\nnewQSem initial\n  | initial < 0 = fail \"newQSem: Initial quantity must be non-negative\"\n  | otherwise   = do\n      sem <- newMVar (initial, [], [])\n      return (QSem sem)", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/QSem.hs--waitQSem", "code": "waitQSem :: QSem -> IO ()\nwaitQSem (QSem m) =\n  mask_ $ do\n    (i,b1,b2) <- takeMVar m\n    if i == 0\n       then do\n         b <- newEmptyMVar\n         putMVar m (i, b1, b:b2)\n         wait b\n       else do\n         let !z = i-1\n         putMVar m (z, b1, b2)\n         return ()\n  where\n    wait b = takeMVar b `onException`\n                (uninterruptibleMask_ $ do -- Note [signal uninterruptible]\n                   (i,b1,b2) <- takeMVar m\n                   r <- tryTakeMVar b\n                   r' <- if isJust r\n                            then signal (i,b1,b2)\n                            else do putMVar b (); return (i,b1,b2)\n                   putMVar m r')", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/QSem.hs--signalQSem", "code": "signalQSem :: QSem -> IO ()\nsignalQSem (QSem m) =\n  uninterruptibleMask_ $ do -- Note [signal uninterruptible]\n    r <- takeMVar m\n    r' <- signal r\n    putMVar m r'", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/QSem.hs--signal", "code": "signal :: (Int,[MVar ()],[MVar ()]) -> IO (Int,[MVar ()],[MVar ()])\nsignal (i,a1,a2) =\n if i == 0\n   then loop a1 a2\n   else let !z = i+1 in return (z, a1, a2)\n where\n   loop [] [] = return (1, [], [])\n   loop [] b2 = loop (reverse b2) []\n   loop (b:bs) b2 = do\n     r <- tryPutMVar b ()\n     if r then return (0, bs, b2)\n          else loop bs b2", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/Chan.hs--newChan", "code": "newChan :: IO (Chan a)", "type": "Monomorphic"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/Chan.hs--writeChan", "code": "writeChan :: Chan a -> a -> IO ()\nwriteChan (Chan _ writeVar) val = do\n  new_hole <- newEmptyMVar\n  mask_ $ do\n    old_hole <- takeMVar writeVar\n    putMVar old_hole (ChItem val new_hole)\n    putMVar writeVar new_hole", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/Chan.hs--readChan", "code": "readChan :: Chan a -> IO a\nreadChan (Chan readVar _) =\n  modifyMVar readVar $ \\read_end -> do\n    (ChItem val new_read_end) <- readMVar read_end\n        -- Use readMVar here, not takeMVar,\n        -- else dupChan doesn't work\n    return (new_read_end, val)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/Chan.hs--dupChan", "code": "dupChan :: Chan a -> IO (Chan a)\ndupChan (Chan _ writeVar) = do\n   hole       <- readMVar writeVar\n   newReadVar <- newMVar hole\n   return (Chan newReadVar writeVar)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/Chan.hs--getChanContents", "code": "getChanContents :: Chan a -> IO [a]\ngetChanContents ch\n  = unsafeInterleaveIO (do\n        x  <- readChan ch\n        xs <- getChanContents ch\n        return (x:xs)\n    )", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Concurrent/Chan.hs--writeList2Chan", "code": "writeList2Chan :: Chan a -> [a] -> IO ()\nwriteList2Chan ch ls = sequence_ (map (writeChan ch) ls)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Monad/Zip.hs--mzip", "code": "mzip :: m a -> m b -> m (a,b)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Monad/Zip.hs--mzipWith", "code": "mzipWith :: (a -> b -> c) -> m a -> m b -> m c\nmzipWith _ _ _ = Proxy\nmzipWith _ _ _ = U1\nmzipWith f (Alt ma) (Alt mb) = Alt (mzipWith f ma mb)\nmzipWith f (M1 fa) (M1 fb) = M1 (mzipWith f fa fb)\nmzipWith f (Rec1 fa) (Rec1 fb) = Rec1 (mzipWith f fa fb)\nmzipWith f (x1 :*: y1) (x2 :*: y2) = mzipWith f x1 x2 :*: mzipWith f y1 y2\nmzipWith f ma mb = liftM (uncurry f) (mzip ma mb)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Monad/Zip.hs--munzip", "code": "munzip :: m (a,b) -> (m a, m b)\nmunzip (Identity (a, b)) = (Identity a, Identity b)\nmunzip (MkSolo (a, b)) = (MkSolo a, MkSolo b)\nmunzip mab = (liftM fst mab, liftM snd mab)", "type": "Parametric"}
{"id": "data/repos/base-4.20.0.0/src/Control/Monad/IO/Class.hs--IO a -> m a\n\n-- | @si", "code": "IO a -> m a\n\n-- | @si", "type": "Parametric"}
